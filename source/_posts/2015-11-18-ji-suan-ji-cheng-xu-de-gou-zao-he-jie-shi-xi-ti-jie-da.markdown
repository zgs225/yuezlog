---
layout: post
title: "计算机程序的构造和解释-习题解答"
keywords:
  - 计算机程序的构造和解释,
  - 习题解答,
  - Structure and Interpretation of Computer Programs,
date: 2015-11-18 00:18:12 +0800
comments: true
categories:
  - 技术
---
目标是完成《计算机程序的构造和解释》一书所有的习题。会不断更新，希望在年底之前能
完成。

## 第一章： 构造过程抽象

### 1.1 程序设计的基本元素

+ 1.1.1 表达式
+ 1.1.2 命名和环境
+ 1.1.3 组合式的求值
+ 1.1.4 复合过程
+ 1.1.5 过程应用的代换模型
+ 1.1.6 条件表达式和谓词([练习 1.1](/sicp-ex1-1)，[练习 1.2](/sicp-ex1-2)，[练习 1.3](/sicp-ex1-3)，[练习 1.4](/sicp-ex1-4)，[练习 1.5](/sicp-ex1-5))
+ 1.1.7 实例：采用牛顿法求平方根([练习 1.6](/sicp-ex1-6)，[练习 1.7](/sicp-ex1-7)，[练习 1.8](/sicp-ex1-8))
+ 1.1.8 过程作为黑箱抽象

### 1.2 过程与它们所产生的计算

+ 1.2.1 线性的递归和迭代([练习 1.9](/sicp-ex1-9)，[练习 1.10](/sicp-ex1-10))
+ 1.2.2 树形递归([练习 1.11](/sicp-ex1-11)，[练习 1.12](/sicp-ex1-12)，[练习 1.13](/sicp-ex1-13))
+ 1.2.3 增长的阶([练习 1.14](/sicp-ex1-14)，[练习 1.15](/sicp-ex1-15))
+ 1.2.4 求幂([练习 1.16](/sicp-ex1-16)，[练习 1.17](/sicp-ex1-17)，[练习 1.18](/sicp-ex1-18)，[练习 1.19](/sicp-ex1-19))
+ 1.2.5 最大公约数([练习 1.20](/sicp-ex1-20))
+ 1.2.6 实例：素数检测([练习 1.21](/sicp-ex1-21)，[练习 1.22](/sicp-ex1-22)，[练习 1.23](/sicp-ex1-23)，[练习 1.24](/sicp-ex1-24)，[练习 1.25](/sicp-ex1-25)，[练习 1.26](/sicp-ex1-26)，[练习 1.27](/sicp-ex1-27)，[练习 1.28](/sicp-ex1-28))

### 1.3 用高阶函数做抽象

+ 1.3.1 过程作为参数([练习 1.29](/sicp-ex1-29)，[练习 1.30](/sicp-ex1-30)，[练习 1.31](/sicp-ex1-31)，[练习 1.32](/sicp-ex1-32)，[练习 1.33](/sicp-ex1-33))
+ 1.3.2 用 lambda 构造过程([练习 1.34](/sicp-ex1-34))
+ 1.3.3 过程作为一般性的方法([练习 1.35](/sicp-ex1-35)，[练习 1.36](/sicp-ex1-36)，[练习 1.37](/sicp-ex1-37)，[练习 1.38](/sicp-ex1-38)，[练习 1.39](/sicp-ex1-39))
+ 1.3.4 过程作为返回值([练习 1.40](/sicp-ex1-40)，[练习 1.41](/sicp-ex1-41)，[练习 1.42](/sicp-ex1-42)，[练习 1.43](/sicp-ex1-43)，[练习 1.44](/sicp-ex1-44)，[练习 1.45](/sicp-ex1-45)，[练习 1.46](/sicp-ex1-46))

## 第二章： 构造数据抽象

### 2.1 数据抽象导引

+ 2.1.1 实例：有理数的算术运算([练习 2.1](/sicp-ex2-1))
+ 2.1.2 抽象屏障(练习 2.2，练习 2.3)
+ 2.1.3 数据意味着什么(练习 2.4，练习 2.5，练习 2.6)
+ 2.1.4 扩展练习：区间算术(练习 2.7，练习 2.8，练习 2.9，练习 2.10，练习 2.11，练习 2.12，练习 2.13，练习 2.14，练习 2.15，练习 2.16)

### 2.2 层次性数据和闭包性质

+ 2.2.1 序列的表示(练习 2.17，练习 2.18，练习 2.19，练习 2.20，练习 2.21，练习 2.22，练习 2.23)
+ 2.2.2 层次性结构(练习 2.24，练习 2.25，练习 2.26，练习 2.27，练习 2.28，练习 2.29，练习 2.30，练习 2.31，练习 2.32)
+ 2.2.3 序列作为一种约定的界面(练习 2.33，练习 2.34，练习 2.35，练习 2.36，练习 2.37，练习 2.38，练习 2.39，练习 2.40，练习 2.41，练习 2.42，练习 2.43)
+ 2.2.4 实例：一个图形语言(练习 2.44，练习 2.45，练习 2.46，练习 2.47，练习 2.48，练习 2.49，练习 2.50，练习 2.51，练习 2.52)

### 2.3 符号数据

+ 2.3.1 引号(练习 2.53，练习 2.54，练习 2.55)
+ 2.3.2 实例：符号求导(练习 2.56，练习 2.57，练习 2.58)
+ 2.3.3 实例：集合的表示(练习 2.59，练习 2.60，练习 2.61，练习 2.62，练习 2.63，练习 2.64，练习 2.65，练习 2.66)
+ 2.3.4 实例：Huffman 编码树(练习 2.67，练习 2.68，练习 2.69，练习 2.70，练习 2.71，练习 2.72)

### 2.4 抽象数据的多重表示

+ 2.4.1 复数的表示
+ 2.4.2 带标志数据
+ 2.4.3 数据导向的程序设计的可加性(练习 2.73，练习 2.74，练习 2.75，练习 2.76)

### 2.5 带有通用型操作的系统

+ 2.5.1 通用型算术运算(练习 2.77，练习 2.78，练习 2.79， 练习 2.80)
+ 2.5.2 不同类型数据的组合(练习 2.81，练习 2.82，练习 2.83，练习 2.84，练习 2.85，练习 2.86)
+ 2.5.3 实例： 符号代数(练习 2.87，练习 2.88，练习 2.89，练习 2.90，练习 2.91，练习 2.92，练习 2.93，练习 2.94，练习 2.95，练习 2.96，练习 2.97)

## 第三章： 模块化、对象和状态

### 3.1 赋值和局部状态

+ 3.1.1 局部状态变量(练习 3.1，练习 3.2，练习 3.3，练习 3.4)
+ 3.1.2 引进赋值带来的利益(练习 3.5，练习 3.6)
+ 3.1.3 引进赋值的代价(练习 3.7，练习 3.8)

### 3.2 求值的环境模型

+ 3.2.1 求值规则
+ 3.2.2 简单过程的应用(练习 3.9)
+ 3.2.3 将框架看作局部状态的展台(练习 3.10)
+ 3.2.4 内部定义(练习 3.11)

### 3.3 用变动数据做模拟

+ 3.3.1 变动的表结构(练习 3.12，练习 3.13，练习 3.14，练习 3.15，练习 3.16，练习 3.17，练习 3.18，练习 3.19，练习 3.20)
+ 3.3.2 队列的表示(练习 3.21，练习 3.22，练习 3.23)
+ 3.3.3 表格的表示(练习 3.24，练习 3.25，练习 3.26，练习 3.27)
+ 3.3.4 数字电路的模拟器(练习 3.28，练习 3.29，练习 3.30，练习 3.31，练习 3.32)
+ 3.3.5 约束的传播(练习 3.33，练习 3.34，练习 3.35，练习 3.36，练习 3.37)

### 3.4 并发：时间是一个本质问题

+ 3.4.1 并发系统中时间的性质(练习 3.38)
+ 3.4.2 控制并发的机制(练习 3.39，练习 3.40，练习 3.41，练习 3.42，练习 3.43，练习 3.44，练习 3.45，练习 3.46，练习 3.47，练习 3.48，练习 3.49)

## 3.5 流

+ 3.5.1 流作为延时的表(练习 3.50，练习 3.51，练习 3.52)
+ 3.5.2 无穷流(练习 3.53，练习 3.54，练习 3.55，练习 3.56，练习 3.57，练习 3.58，练习 3.59，练习 3.60，练习 3.61，练习 3.62)
+ 3.5.3 流计算模式的使用(练习 3.63，练习 3.64，练习 3.65，练习 3.66，练习 3.67，练习 3.68，练习 3.69，练习 3.70，练习 3.71，练习 3.72，练习 3.73，练习 3.74，练习 3.75，练习 3.76)
+ 3.5.4 流和延时求值(练习 3.77，练习 3.78，练习 3.79，练习 3.80)
+ 3.5.5 函数式程序的模块化和对象的模块化(练习 3.81，练习 3.82)

## 第四章： 元语言抽象

### 4.1 元循环求值器

+ 4.1.1 求值器的内核(练习 4.1)
+ 4.1.2 表达式的表示(练习 4.2，练习 4.3，练习 4.4，练习 4.5，练习 4.6，练习 4.7，练习 4.8，练习 4.9，练习 4.10)
+ 4.1.3 求值器数据结构(练习 4.11，练习 4.12，练习 4.13)
+ 4.1.4 作为程序运行这个求值器(练习 4.14)
+ 4.1.5 将数据作为程序(练习 4.15)
+ 4.1.6 内部表示(练习 4.16，练习 4.17，练习 4.18，练习 4.19，练习 4.20，练习 4.21)
+ 4.1.7 将语法分析和执行分离(练习 4.22，练习 4.23，练习 4.24)

### 4.2 Scheme 的变形 —— 惰性求值

+ 4.2.1 正则序和应用序(练习 4.25，练习 4.26)
+ 4.2.2 一个采用惰性求值的解释器(练习 4.27，练习 4.28，练习 4.29，练习 4.30，练习 4.31)
+ 4.2.3 将流作为惰性的表(练习 4.32，练习 4.33，练习 4.34)

###4.3 Scheme 的变形 —— 非确定性求值

+ 4.3.1 amb 和搜索(练习 4.35，练习 4.36，练习 4.37)
+ 4.3.2 非确定性程序的实例(练习 4.38，练习 4.39，练习 4.40，练习 4.41，练习 4.42，练习 4.43，练习 4.44，练习 4.45，练习 4.46，练习 4.47，练习 4.48，练习 4.49)
+ 4.3.3 实现 amb 求值器(练习 4.50，练习 4.51，练习 4.52，练习 4.53，练习 4.54)

### 4.4 逻辑程序设计

+ 4.4.1 演绎信息检索(练习 4.55，练习 4.56，练习 4.57，练习 4.58，练习 4.59，练习 4.60，练习 4.61，练习 4.62，练习 4.63)
+ 4.4.2 查询系统如何工作
+ 4.4.3 逻辑程序设计是数理逻辑吗(练习 4.64，练习 4.65，练习 4.66，练习 4.67，练习 4.68，练习 4.69)
+ 4.4.4 查询系统的实现(练习 4.70，练习 4.71，练习 4.72，练习 4.73，练习 4.74，练习 4.75，练习 4.76，练习 4.77，练习 4.78，练习 4.79)

## 第五章： 寄存器机器里的计算

### 5.1 寄存器机器的设计(练习 5.1)

+ 5.1.1 一种描述寄存器机器的语言(练习 5.2)
+ 5.1.2 机器设计的抽象(练习 5.3)
+ 5.1.3 子程序
+ 5.1.4 采用堆栈实现递归(练习 5.4，练习 5.5，练习 5.6)
+ 5.1.5 指令总结

### 5.2 一个寄存器机器模拟器(练习 5.7)

+ 5.2.1 机器模型
+ 5.2.2 汇编程序(练习 5.8)
+ 5.2.3 为指令生成执行过程(练习 5.9，练习 5.10，练习 5.11，练习 5.12，练习 5.13)
+ 5.2.4 监视机器执行(练习 5.14，练习 5.15，练习 5.16，练习 5.17，练习 5.18，练习 5.19)

### 5.3 存储分配和废料收集

+ 5.3.1 将存储看作向量(练习 5.20，练习 5.21，练习 5.22)
+ 5.3.2 维持一种无穷存储的假象

### 5.4 显式控制的求值器

+ 5.4.1 显式控制求值器的内核
+ 5.4.2 序列的求值和尾递归
+ 5.4.3 条件、赋值和定义(练习 5.23，练习 5.24，练习 5.25)
+ 5.4.4 求值器的运行(练习 5.26，练习 5.27，练习 5.28，练习 5.29，练习 5.30)

### 5.5 编译

+ 5.5.1 编译器的结构(练习 5.31，练习 5.32)
+ 5.5.2 表达式的编译
+ 5.5.3 组合式的编译
+ 5.5.4 指令序列的组合
+ 5.5.5 编译代码的实例(练习 5.33，练习 5.34，练习 5.35，练习 5.36，练习 5.37，练习 5.38)
+ 5.5.6 词法地址(练习 5.39，练习 5.40，练习 5.41，练习 5.42，练习 5.43，练习 5.44)
+ 5.5.7 编译代码和求值器的互连(练习 5.45，练习 5.46，练习 5.47，练习 5.48，练习 5.49，练习 5.50，练习 5.51，练习 5.52)
