(define (eval exp env)
  (let ((type (exp-type exp)))
    (apply-generic type (exp-content exp) env)))

(define (exp-type exp) (car exp))
(define (exp-content) (cdr exp))

(define operation-table (make-eq-hash-table))
(define (put key datum) (hash-table/put! operation-table key datum))
(define (get key) (hash-table/get operation-table key #f))

(define (apply-generic op . args)
  (let ((proc (get op)))
    (if proc
        (apply proc args)
        (error "Unknown expression type -- EVAL" exp))))

(define (eval-and exp env)
  (define (internal remains)
    (cond ((null? remains) #t)
          ((not (eval (car remains) env)) #f)
          (else (internel (cdr remains)))))
  (internal (cdr exp)))

(define (eval-or exp env)
  (define (internal remains)
    (cond ((null? remains) #f)
          ((eval (car remains) env) #t)
          (else (internal (cdr remains)))))
  (internal (cdr exp)))

(put 'and eval-and)
(put 'or eval-or)
(put 'self-evaluating (lambda (exp env) (exp)))
(put 'variable lookup-variable-value)
(put 'quoted (lambda (exp env) (text-of-quotation exp)))
(put 'assignment evel-assignment)
(put 'definition eval-definition)
(put 'if eval-if)
(put 'lambda (lambda (exp env)
                (make-procedure (lambda-parameters exp)
                                (lambda-body exp)
                                env)))
(put 'begin (lambda (exp env)
              (eval-sequence (begin-actions exp) env)))
(put 'cond cond->if)
(put 'application (lambda (exp env)
                    (apply (eval (operator exp) env)
                           (list-of-values (operands exp) env))))
